# Rust/pgrx container for pg_sexp extension
# Usage: podman build -f Containerfile.rust -t localhost/pg_sexp-rust .
#        podman run --rm localhost/pg_sexp-rust

# Using Fedora for glibc (required by pgrx bindgen for dlopen)
# This avoids Docker Hub rate limits by using quay.io
FROM quay.io/fedora/fedora:41 AS builder

ARG PG_VERSION=18.1

# Install Rust and build dependencies
RUN dnf install -y \
    rust cargo rustfmt \
    clang clang-devel llvm-devel \
    readline-devel zlib-devel openssl-devel libicu-devel \
    bison flex wget perl pkg-config \
    gcc make \
    && dnf clean all

WORKDIR /build

# Download and build PostgreSQL 18.1
RUN wget -q https://ftp.postgresql.org/pub/source/v${PG_VERSION}/postgresql-${PG_VERSION}.tar.bz2 && \
    tar xjf postgresql-${PG_VERSION}.tar.bz2 && \
    cd postgresql-${PG_VERSION} && \
    ./configure \
        --prefix=/usr/local/pgsql \
        --with-openssl \
        --with-llvm \
        LLVM_CONFIG=/usr/bin/llvm-config && \
    make -j$(nproc) && \
    make install

# Set up PostgreSQL environment
ENV PATH="/usr/local/pgsql/bin:$PATH"
ENV LD_LIBRARY_PATH="/usr/local/pgsql/lib"

# Install pgrx 0.16 (supports pg18, requires Rust 1.85+)
RUN cargo install cargo-pgrx --version 0.16.1 --locked

# Initialize pgrx with our PostgreSQL 18
RUN cargo pgrx init --pg18=/usr/local/pgsql/bin/pg_config

# Copy Rust extension source
WORKDIR /build/pg_sexp_rs
COPY rs/Cargo.toml rs/pg_sexp_rs.control ./
COPY rs/src/ src/

# Build the extension
RUN cargo pgrx package --pg-config /usr/local/pgsql/bin/pg_config

# Install extension files
RUN cp target/release/pg_sexp_rs-pg18/usr/local/pgsql/lib/pg_sexp_rs.so /usr/local/pgsql/lib/ && \
    cp target/release/pg_sexp_rs-pg18/usr/local/pgsql/share/extension/pg_sexp_rs* /usr/local/pgsql/share/extension/

# ============================================================================
# Runtime image
# ============================================================================
FROM quay.io/fedora/fedora:41

ARG PG_VERSION=18.1

# Install runtime dependencies
RUN dnf install -y \
    readline zlib openssl libicu llvm-libs \
    shadow-utils util-linux \
    && dnf clean all

# Copy PostgreSQL and extension from builder
COPY --from=builder /usr/local/pgsql /usr/local/pgsql

# Set up PostgreSQL environment
ENV PATH="/usr/local/pgsql/bin:$PATH"
ENV LD_LIBRARY_PATH="/usr/local/pgsql/lib"
ENV PGDATA="/tmp/pgdata"

# Create postgres user and directories
RUN groupadd -r -g 70 postgres && \
    useradd -r -u 70 -g postgres -d /var/lib/postgresql -s /bin/bash postgres && \
    mkdir -p /var/run/postgresql && \
    mkdir -p /tmp/pgdata && \
    chown -R postgres:postgres /var/run/postgresql /tmp/pgdata

# Set up test script
COPY --chmod=755 <<'EOF' /run-tests.sh
#!/bin/bash
set -e

export PATH="/usr/local/pgsql/bin:$PATH"
export LD_LIBRARY_PATH="/usr/local/pgsql/lib"

run_as_postgres() {
    su postgres -s /bin/bash -c "export PATH=/usr/local/pgsql/bin:\$PATH; export LD_LIBRARY_PATH=/usr/local/pgsql/lib; $1"
}

# Initialize database cluster
echo "Initializing PostgreSQL 18.1..."
run_as_postgres "initdb -D /tmp/pgdata --auth=trust --no-locale --encoding=UTF8"

# Configure PostgreSQL to use Unix socket only (no TCP)
cat >> /tmp/pgdata/postgresql.conf << 'PGCONF'
listen_addresses = ''
unix_socket_directories = '/var/run/postgresql'
PGCONF

# Start PostgreSQL
echo "Starting PostgreSQL..."
run_as_postgres "pg_ctl -D /tmp/pgdata -l /tmp/pg.log start"

# Wait for PostgreSQL to be ready (using socket)
echo "Waiting for PostgreSQL to start..."
while ! run_as_postgres "pg_isready -h /var/run/postgresql" >/dev/null 2>&1; do
    sleep 1
done
echo "PostgreSQL is ready!"

# Create test database
run_as_postgres "createdb -h /var/run/postgresql testdb"
run_as_postgres "psql -h /var/run/postgresql -d testdb -c 'CREATE EXTENSION pg_sexp_rs;'"

echo ""
echo "=== Basic Tests ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Test basic parsing
SELECT '(foo bar baz)'::sexp;
SELECT '42'::sexp;
SELECT '"hello world"'::sexp;
SELECT '()'::sexp;

-- Test nested structures
SELECT '(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))'::sexp;

-- Test functions
SELECT car('(a b c)'::sexp);
SELECT cdr('(a b c)'::sexp);
SELECT nth('(a b c d)'::sexp, 2);
SELECT sexp_length('(a b c d e)'::sexp);

-- Test type checking
SELECT sexp_typeof('foo'::sexp);
SELECT sexp_typeof('42'::sexp);
SELECT sexp_typeof('(list of stuff)'::sexp);
SELECT sexp_typeof('"a string"'::sexp);

SELECT is_nil('()'::sexp);
SELECT is_list('(a b c)'::sexp);
SELECT is_atom('foo'::sexp);
SELECT is_symbol('foo'::sexp);
SELECT is_string('"foo"'::sexp);
SELECT is_number('42'::sexp);

-- Test operators
SELECT '(a b)'::sexp = '(a b)'::sexp AS should_be_true;
SELECT '(a b)'::sexp <> '(a c)'::sexp AS should_be_true;

-- Test containment
SELECT '(a (b c) d)'::sexp @> '(b c)'::sexp AS should_be_true;
SELECT '(b c)'::sexp <@ '(a (b c) d)'::sexp AS should_be_true;

-- Test hash
SELECT sexp_hash('(test value)'::sexp);
SQL

echo ""
echo "=== Table Tests ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Create table with sexp column
CREATE TABLE test_sexps (
    id serial PRIMARY KEY,
    data sexp
);

-- Insert some data
INSERT INTO test_sexps (data) VALUES 
    ('(define x 42)'::sexp),
    ('(lambda (x) (* x x))'::sexp),
    ('(if (> x 0) positive negative)'::sexp),
    ('(list 1 2 3 4 5)'::sexp);

-- Query data
SELECT * FROM test_sexps;

-- Find specific patterns
SELECT * FROM test_sexps WHERE car(data) = 'define'::sexp;

-- Test containment query
SELECT * FROM test_sexps WHERE data @> '(* x x)'::sexp;

-- Create hash index
CREATE INDEX test_sexps_hash_idx ON test_sexps USING hash (data);

-- Test index usage
EXPLAIN (COSTS OFF) SELECT * FROM test_sexps WHERE data = '(define x 42)'::sexp;
SQL

echo ""
echo "=== Pattern Matching Tests ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Basic wildcard matching
SELECT '(foo bar baz)'::sexp ~ '(foo _ baz)'::sexp AS wildcard_match;

-- Rest wildcard matching
SELECT '(foo a b c d)'::sexp ~ '(foo _*)'::sexp AS rest_match;

-- Capture pattern (acts like wildcard)
SELECT '(define x 42)'::sexp ~ '(define ?name ?value)'::sexp AS capture_match;

-- No match case
SELECT '(foo bar)'::sexp ~ '(foo baz)'::sexp AS should_be_false;

-- Pattern in nested structure
SELECT '(defun add (x y) (+ x y))'::sexp ~ '(defun add _ _*)'::sexp AS nested_match;

-- sexp_find function
SELECT sexp_find('(a (b (c d)) e)'::sexp, '(c _)'::sexp) AS found;
SQL

echo ""
echo "=== Key-Based Containment Tests (@>>) ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Simple key-value containment
SELECT '(user (id 100) (name "John") (age 30))'::sexp @>> '(name "John")'::sexp AS key_match;

-- Nested key-value containment
SELECT '(data (user (id 100)))'::sexp @>> '(id 100)'::sexp AS nested_key_match;

-- No match case
SELECT '(user (id 100) (name "John"))'::sexp @>> '(name "Jane")'::sexp AS should_be_false;

-- Complex structure
CREATE TABLE users (
    id serial PRIMARY KEY,
    profile sexp
);

INSERT INTO users (profile) VALUES
    ('(user (id 1) (name "Alice") (email "alice@example.com") (admin true))'::sexp),
    ('(user (id 2) (name "Bob") (email "bob@example.com") (admin false))'::sexp),
    ('(user (id 3) (name "Charlie") (email "charlie@example.com") (admin true))'::sexp);

-- Find admin users
SELECT * FROM users WHERE profile @>> '(admin true)'::sexp;

-- Find specific user
SELECT * FROM users WHERE profile @>> '(name "Alice")'::sexp;
SQL

echo ""
echo "=== GIN Key Extraction Tests ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Test key extraction
SELECT sexp_extract_keys('(foo bar baz)'::sexp) AS keys;
SELECT sexp_extract_keys('(id 100)'::sexp) AS pair_keys;
SELECT sexp_extract_keys('(user (name "test"))'::sexp) AS nested_keys;
SQL

echo ""
echo "=== GIN Index Tests ==="
echo ""

run_as_postgres "psql -h /var/run/postgresql -d testdb" << 'SQL'
-- Create table with more data for GIN index testing
CREATE TABLE sexp_data (
    id serial PRIMARY KEY,
    expr sexp
);

-- Insert sample data
INSERT INTO sexp_data (expr) 
SELECT ('(item ' || i || ' (name "item' || i || '") (value ' || (i * 10) || '))')::sexp
FROM generate_series(1, 1000) AS i;

-- Also add some specific test data
INSERT INTO sexp_data (expr) VALUES
    ('(special (id 999) (name "target") (active true))'::sexp),
    ('(special (id 998) (name "other") (active false))'::sexp);

-- Check table size
SELECT COUNT(*) AS row_count FROM sexp_data;

-- Create GIN index
CREATE INDEX sexp_data_gin_idx ON sexp_data USING gin (expr sexp_gin_ops);

-- Verify GIN index exists
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'sexp_data' AND indexdef LIKE '%gin%';

-- Test structural containment with GIN
EXPLAIN (COSTS OFF) SELECT * FROM sexp_data WHERE expr @> '(active true)'::sexp;
SELECT COUNT(*) FROM sexp_data WHERE expr @> '(active true)'::sexp;

-- Test key-based containment with GIN  
EXPLAIN (COSTS OFF) SELECT * FROM sexp_data WHERE expr @>> '(name "target")'::sexp;
SELECT * FROM sexp_data WHERE expr @>> '(name "target")'::sexp;

-- Test that index is actually being used (should show Index Scan or Bitmap Index Scan)
SET enable_seqscan = OFF;
EXPLAIN (COSTS OFF) SELECT * FROM sexp_data WHERE expr @> '(special _*)'::sexp;
SET enable_seqscan = ON;

\echo 'GIN index tests completed!'
SQL

echo ""
echo "=== All tests passed! ==="

# Cleanup
run_as_postgres "pg_ctl -D /tmp/pgdata stop"
EOF

CMD ["/run-tests.sh"]
